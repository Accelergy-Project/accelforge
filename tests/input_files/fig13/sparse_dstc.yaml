# Fig 13 DSTC sparse config: Dual-Side Sparse Tensor Core
# Translated from Sparseloop's sparse-opt.yaml with explicit per-rank format.
#
# Sparseloop uses inner-to-outer rank application; AccelForge uses outer-to-inner.
# So the rank ordering is REVERSED from Sparseloop's config.
#
# SAF: position-skipping at LineBuffer for A and B (self-conditioned)
# SAF: skipping at Buffer for Z conditioned on A and B
# No compute_optimization at MAC (matches Sparseloop reference config;
# compute cycles reduced via storage SAF propagation from position-skipping).

sparse_optimizations:
  targets:
  - target: DRAM
    representation_format:
    # Sparseloop inner-to-outer: UOP, UOP, UOP, UOP, UOP, B, B(1, [[M]])
    # AccelForge outer-to-inner: B(1, [[M]]), B, UOP, UOP, UOP, UOP, UOP
    - name: A
      ranks:
      - {format: B, metadata_word_bits: 1, flattened_rank_ids: [["M"]]}
      - {format: B, metadata_word_bits: 1}
      - {format: UOP}
      - {format: UOP}
      - {format: UOP}
      - {format: UOP}
      - {format: UOP}
    # Sparseloop inner-to-outer: UOP, UOP, UOP, UOP, UOP, B, B(1, [[N]])
    # AccelForge outer-to-inner: B(1, [[N]]), B, UOP, UOP, UOP, UOP, UOP
    - name: B
      ranks:
      - {format: B, metadata_word_bits: 1, flattened_rank_ids: [["N"]]}
      - {format: B, metadata_word_bits: 1}
      - {format: UOP}
      - {format: UOP}
      - {format: UOP}
      - {format: UOP}
      - {format: UOP}

  - target: GLB
    representation_format:
    # Sparseloop inner-to-outer: UOP, UOP, UOP, B, B(1, [[M]])
    # AccelForge outer-to-inner: B(1, [[M]]), B, UOP, UOP, UOP
    - name: A
      ranks:
      - {format: B, metadata_word_bits: 1, flattened_rank_ids: [["M"]]}
      - {format: B, metadata_word_bits: 1}
      - {format: UOP}
      - {format: UOP}
      - {format: UOP}
    # Sparseloop inner-to-outer: UOP, UOP, UOP, B, B(1, [[N]])
    # AccelForge outer-to-inner: B(1, [[N]]), B, UOP, UOP, UOP
    - name: B
      ranks:
      - {format: B, metadata_word_bits: 1, flattened_rank_ids: [["N"]]}
      - {format: B, metadata_word_bits: 1}
      - {format: UOP}
      - {format: UOP}
      - {format: UOP}

  - target: LineBuffer
    representation_format:
    # Sparseloop inner-to-outer: UOP, UOP, B(1), B(1)
    # AccelForge outer-to-inner: B(1), B(1), UOP, UOP
    - name: A
      ranks:
      - {format: B, metadata_word_bits: 1, flattened_rank_ids: [["M"]]}
      - {format: B, metadata_word_bits: 1}
      - {format: UOP}
      - {format: UOP}
    - name: B
      ranks:
      - {format: B, metadata_word_bits: 1, flattened_rank_ids: [["N"]]}
      - {format: B, metadata_word_bits: 1}
      - {format: UOP}
      - {format: UOP}
    action_optimization:
    - kind: position_skipping
      target: A
      condition_on: []
    - kind: position_skipping
      target: B
      condition_on: []

  - target: Buffer
    action_optimization:
    - kind: skipping
      target: Z
      condition_on: [A, B]

  # No compute_optimization at MAC — matches Sparseloop reference config.
  # Compute cycles are still reduced via storage SAF propagation (Phase 4b):
  # position-skipping on A and B at LineBuffer → compound survival dA*dB.
